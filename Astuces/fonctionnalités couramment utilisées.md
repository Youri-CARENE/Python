Variables et types de données

x = 10 : affecte la valeur 10 à la variable x.
y = 'Hello World!' : affecte la chaîne de caractères 'Hello World!' à la variable y.
type(x) : affiche le type de la variable x.
type(y) : affiche le type de la variable y.
int() : crée un objet de type entier.
float() : crée un objet de type flottant.
str() : crée un objet de type chaîne de caractères.
Structures de contrôle de flux

if : permet de tester une condition.
else : permet d'exécuter un bloc de code si la condition testée est fausse.
elif : permet de tester une condition supplémentaire.
for : permet de parcourir une liste ou une séquence.
while : permet d'exécuter une boucle tant qu'une condition est vraie.
break : permet de sortir d'une boucle.
continue : permet de passer à l'itération suivante d'une boucle.
Listes et dictionnaires

my_list = [1, 2, 3, 4] : crée une liste avec les éléments 1, 2, 3 et 4.
my_dict = {'key1': 'value1', 'key2': 'value2'} : crée un dictionnaire avec les clés et les valeurs correspondantes.
len(my_list) : renvoie la longueur de la liste my_list.
my_list.append(5) : ajoute l'élément 5 à la fin de la liste my_list.
my_dict.keys() : renvoie une liste des clés du dictionnaire my_dict.
my_dict.values() : renvoie une liste des valeurs du dictionnaire my_dict.
Fonctions

def my_function(param1, param2): : crée une nouvelle fonction nommée my_function qui prend deux paramètres.
return : renvoie une valeur depuis une fonction.
my_function(x, y) : appelle la fonction my_function avec les arguments x et y.
Gestion des erreurs

try : permet d'essayer une instruction susceptible de générer une erreur.
except : permet de gérer les erreurs éventuellement levées.
finally : permet d'exécuter du code après la gestion d'erreur, qu'il y ait eu une erreur ou non.
Importation de modules

import module_name : importe un module nommé module_name.
from module_name import function_name : importe une fonction spécifique d'un module.
import module_name as alias : importe un module avec un alias.